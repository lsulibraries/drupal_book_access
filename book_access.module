<?php
// $Id$

/**
 * @file
 *
 * Allows to set the access control for book nodes on a per book basis.
 * Based on forum_access.module and tac_lite.module.
 */

/**
 * The API version implemented by the module.
 */
define('BOOK_ACCESS_API_VERSION', '2.2');

/**
 * The default priority used by the access grants implemented by the module.
 */
define('BOOK_ACCESS_GRANT_PRIORITY', 0);

/**
 * Allows to access the Drupal variables used by the module.
 */
class BookAccessVars extends Vars {
  /**
   * Constructs a BookAccessVars object.
   */
  public function __construct() {
   parent::__construct('book_access', array(
     'sysVars' => array(
       'menu_rebuild_needed' => FALSE,
       'book_child_type' => 'book',
     )
   ));
  }

  /**
   * Implements Vars::getDefaults().
   */
  protected function getDefaults() {
    return array(
      'book_access_default_authors_access' => array('value' => array()),
      'book_access_default_roles_access' => array('value' => array()),
      'book_access_default_users_access' => array('value' => array()),
    );
  }
}

/**
 * Implements hook_form_alter().
 *
 * @see book_outline_form()
 * @see book_access_outline_form_submit()
 * @see book_access_edit_form_submit()
 *
 */
function book_access_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    if (isset($form['book']['bid']['#options'])) {
      _book_access_options_restrict($form['book']['bid']['#options']);
    }

    $form['#submit'][] = 'book_access_edit_form_submit';
  }
  // When an outline is modified, the taxonomy is changed but the node is not
  // saved; node grants can become broken if a book page is moved into
  // another book. We fix that by adding an additional #submit callback
  // to rebuild the grants when the book outline is modified.
  elseif ($form_id == 'book_outline_form') {
    if (isset($form['book']['bid']['#options'])) {
      _book_access_options_restrict($form['book']['bid']['#options']);
    }

    $form['#submit'][] = 'book_access_outline_form_submit';

    if (isset($form['remove'])) {
      $form['remove']['#submit'][] = 'book_access_edit_form_submit';
    }
  }
}

/**
 * Implements hook_link_alter().
 *
 * Enables the link "Add child page" only for users who have ther right
 * permission.
 */
function book_access_link_alter(&$links, $node) {
  if (user_access('administer nodes')) {
    return;
  }

  if (isset($node->book['bid']) && isset($links['book_add_child'])) {
    $vars = new BookAccessVars();

    $grant_add_child = book_access_grant_check($node->book['bid'], 'add_child');

    $bool = (
      (
        user_access('add content to books') ||
        user_access('administer book outlines') ||
        $grant_add_child
      ) &&
      node_access('create', $vars['book_child_type']) &&
      $node->status == 1 &&
      $node->book['depth'] < MENU_MAX_DEPTH
    );

    if (!$bool) {
      unset($links['book_add_child']);
    }
  }
}

/**
 * Implements hook_menu_alter().
 *
 * @see book_access_outline_access()
 * @see book_access_outline_remove_access()
 */
function book_access_menu_alter(&$items) {
  if (isset($items['node/%node/outline'])) {
    $items['node/%node/outline']['access callback'] = 'book_access_outline_access';
  }

  if (isset($items['node/%node/outline/remove'])) {
    $items['node/%node/outline/remove']['access callback'] = 'book_access_outline_remove_access';
  }
}

/**
 * Implements hook_node_access_explain().
 *
 * hook_node_access_explain() is defined in devel_node_access.module, which
 * helps you to figure out how node access works and what permissions are
 * currently granted.
 */
function book_access_node_access_explain($row) {
  static $roles = NULL;
  $result = array();

  if ($row->realm == 'book_access_author') {
    $result = array(
      t('Grants for book authors')
    );
  }
  elseif ($row->realm == 'book_access_role') {
    if (!isset($roles)) {
      $roles = user_roles();
    }

    if (isset($roles[$row->gid])) {
      $result = array(
        t('Grants for users of role %role',
          array('%role' => $roles[$row->gid])
        )
      );
    }
    else {
      $result = array(
        t('Unknown group ID %gid',
          array('%gid' => $row->gid)
        )
      );
    }
  }
  elseif ($row->realm == 'book_access_user') {
    if ($user = user_load(array('uid' => $row->gid))) {
      $result = array(
        t('Grants for user %username',
          array('%username' => $user->name)
        )
      );
    }
    else {
      $result = array(
        t('Unknown user ID %gid',
          array('%gid' => $row->gid)
        )
      );
    }
  }

  return $result;
}

/**
 * Implements hook_node_access_records().
 *
 * Returns a list of grant records for the book node object passed as argument.
 * If we have a book child page, we return the access settings of the top level
 * parent book page node.
 */
 function book_access_node_access_records($node) {
   $grants = array();

  if (isset($node->book['bid'])) {
    $bid =  $node->book['bid'];
    book_access_author_records($grants, $bid);
    book_access_role_records($grants, $bid);
    book_access_user_records($grants, $bid);
  }

  return $grants;
}

/**
 * Implements hook_node_grants().
 */
function book_access_node_grants($account, $op) {
  $grants = array();

  $grants['book_access_author'] = array($account->uid);
  $grants['book_access_role'] = array_keys($account->roles);
  $grants['book_access_user'] = array($account->uid);

  return $grants;
}

/**
 * Implements hook_nodeapi().
 */
function book_access_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if (!empty($node->nid)) {
    $nid = $node->nid;

    switch ($op) {
      case 'delete':
        db_query("DELETE FROM {book_access_author} WHERE nid = %d", $nid);
        db_query("DELETE FROM {book_access_role} WHERE nid = %d", $nid);
        db_query("DELETE FROM {book_access_user} WHERE nid = %d", $nid);
        break;

      case 'update':
        db_query("UPDATE {book_access_author} SET uid = %d WHERE nid = %d", $node->uid, $nid);
        break;
    }
  }
}

/**
 * Implements hook_perm().
 *
 */
function book_access_perm() {
  return array(
    'administer book access',
    'administer access of any books',
    'administer access of own books',
  );
}

/**
 * Implements hook_user().
 */
function book_access_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete') {
    $uid = $account->uid;
    db_query("DELETE FROM {book_access_author} WHERE uid = %d", $uid);
    db_query("DELETE FROM {book_access_user} WHERE uid = %d", $uid);
  }
}

/**
 * Determines if the outline tab is accessible.
 *
 * @see book_access_menu_alter()
 */
function book_access_outline_access($node) {
  if (!isset($node->book['bid'])) {
    return FALSE;
  }

  $view_access = node_access('view', $node);

  if (user_access('administer book outlines') && $view_access) {
    return TRUE;
  }

  return book_access_grant_check($node->book['bid'], 'edit_outline') && $view_access;
}

/**
 * Determines if the user can remove nodes from the outline.
 *
 * @see book_access_menu_alter()
 */
function book_access_outline_remove_access($node) {
  $bool = (
    isset($node->book['bid']) &&
    ($node->book['bid'] != $node->nid) &&
    book_access_outline_access($node)
  );

  return $bool;
}

/**
 * Form submission callback for node_form(), and book_outline_form().
 *
 * @see node_form()
 * @see book_outline_form()
 * @see book_access_form_alter()
 */
function book_access_edit_form_submit($form, &$form_state) {
  $node = $form['#node'];

  book_access_node_grants_build($node);
}

/**
 * Form submission callback for book_outline_form().
 *
 * @see book_outline_form()
 * @see book_access_form_alter()
 */
function book_access_outline_form_submit($form, &$form_state) {
  $node = $form['#node'];

  if (isset($form['plid']) && $form['plid'] != $form_state['values']['plid']) {
    book_access_node_grants_build($node);
  }
}

/**
 * Verifies the current API version is included between two values passes as
 * arguments.
 *
 * @param $minimum
 *   The minimum API version required.
 * @param $maximum
 *   The maximum version required. This argument is optional; the current API
 *   will be checked against this value only if it is passed to the function.
 *
 * @return
 *   TRUE, if the current API version is included between the passed values.
 */
function book_access_api($minimum, $maximum = NULL) {
  if (version_compare(BOOK_ACCESS_API_VERSION, $minimum, '<')) {
    return FALSE;
  }

  if (isset($maximum) && version_compare(BOOK_ACCESS_API_VERSION, $maximum, '>')) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Adds author grants to book pages.
 *
 * @param $bid
 *   The book ID.
 * @param $uid
 *   The user ID of the book author.
 * @param $grants
 *   An array of grants, in the format @code $grants[$grant] @endcode,
 *   where @code $grant @endcode is a string between 'grant_view',
 *   'grant_update', 'grant_delete', 'grant_admin_access', 'grant_add_child',
 *   'grant_edit_outline'.
 */
 function book_access_author_add($bid, $uid, array $grants) {
  $grant_ids = array(
    'grant_view', 'grant_update', 'grant_delete',
    'grant_admin_access', 'grant_add_child', 'grant_edit_outline',
  );

  $row = new stdClass();
  $row->nid = $bid;
  $row->uid = $uid;

  $bool = db_result(
    db_query_range(
      "SELECT 1 FROM {book_access_author} WHERE nid = %d AND uid = %d",
      $bid, $uid, 0, 1
    )
  );

  foreach ($grant_ids as $id) {
    $row->$id = !empty($grants[$id]);
  }

  drupal_write_record('book_access_author', $row, $bool ? array('nid', 'uid') : array());
}

/**
 * Gets the list of grant records assigned to book authors for a book.
 *
 * @param $grants
 *   An array of grants.
 * @param $bid
 *   The ID of the book for which the function returns the grant records.
 */
function book_access_author_records(&$grants, $bid) {
  $result = db_query('SELECT * FROM {book_access_author} WHERE nid = %d', $bid);

  while ($grant = db_fetch_object($result)) {
    $grants[] = array(
      'realm'        => 'book_access_role',
      'gid'          => $grant->uid,
      'grant_view'   => $grant->grant_view,
      'grant_update' => $grant->grant_update,
      'grant_delete' => $grant->grant_delete,
      'priority'     => BOOK_ACCESS_GRANT_PRIORITY,
    );
  }
}

/**
 * Checks if a user has access to the book passed as argument.
 *
 * @param $bid
 *   The ID of the book to check.
 * @param $grant
 *   The permission to check for.
 * @param $account
 *   The user account for which the permission is checked; if it is not passed,
 *   the permission is checked against the current logged in user.
 *
 * @return
 *   TRUE if the user has the permission, FALSE otherwise.
 */
function book_access_grant_check($bid, $grant, $account = NULL) {
  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  $roles = array_keys($account->roles);
  $result = (
    db_result(
      db_query_range(
        "SELECT 1 FROM {book_access_author} WHERE nid = %d AND uid = %d AND grant_$grant > 0",
        $bid, $user->uid, 0, 1
      )
    ) ||
    db_result(
      db_query_range(
        "SELECT 1 FROM {book_access_role} WHERE nid = %d AND rid IN (" . db_placeholders($roles) . ") AND grant_$grant > 0",
        array_merge(array($bid), $roles), 0, 1
      )
    ) ||
    db_result(
      db_query_range(
        "SELECT 1 FROM {book_access_user} WHERE nid = %d AND uid = %d AND grant_$grant > 0",
        $bid, $user->uid, 0, 1
      )
    )
  );

  return $result;
}

/**
 * Rebuilds the book page grants for the node passed as argument.
 *
 * @param $node
 *   The node for which the grants needs to be rebuilt.
 */
function book_access_node_grants_build($node) {
  if (isset($node->book['bid'])) {
    $grants = array();
    book_access_author_records($grants, $node->book['bid']);
    node_access_write_grants($node, $grants, 'book_access_author');

    $grants = array();
    book_access_role_records($grants, $node->book['bid']);
    node_access_write_grants($node, $grants, 'book_access_role');

    $grants = array();
    book_access_user_records($grants, $node->book['bid']);
    node_access_write_grants($node, $grants, 'book_access_user');
  }
}

/**
 * Adds role grants to book pages.
 *
 * @param $bid
 *   The book ID.
 * @param $rids
 *   An array of role IDs for which to add the book grants.
 * @param $grants
 *   An array of grants, in the format @code $grants[$grant][$rid] @endcode,
 *   where @code $grant @endcode is a string between 'grant_view',
 *   'grant_update', 'grant_delete', 'grant_admin_access', 'grant_add_child',
 *   'grant_edit_outline', and @code $rid @endcode is the role ID.
 */
 function book_access_role_add($bid, array $rids, array $grants) {
  $grant_ids = array(
    'grant_view', 'grant_update', 'grant_delete',
    'grant_admin_access', 'grant_add_child', 'grant_edit_outline',
  );

  $row = new stdClass();
  $row->nid = $bid;

  foreach ($rids as $rid) {
    $row->rid = $rid;

    $bool = db_result(
      db_query_range(
        "SELECT 1 FROM {book_access_role} WHERE nid = %d AND rid = %d",
        $bid, $rid, 0, 1
      )
    );

    foreach ($grant_ids as $id) {
      $row->$id = !empty($grants[$id][$rid]);
    }

    drupal_write_record('book_access_role', $row, $bool ? array('nid', 'rid') : array());
  }
}

/**
 * Gets the list of grant records assigned to user roles for a book.
 *
 * @param $grants
 *   An array of grants.
 * @param $bid
 *   The ID of the book for which the function returns the grant records.
 */
function book_access_role_records(&$grants, $bid) {
  $result = db_query('SELECT * FROM {book_access_role} WHERE nid = %d', $bid);

  while ($grant = db_fetch_object($result)) {
    $grants[] = array(
      'realm'        => 'book_access_role',
      'gid'          => $grant->rid,
      'grant_view'   => $grant->grant_view,
      'grant_update' => $grant->grant_update,
      'grant_delete' => $grant->grant_delete,
      'priority'     => BOOK_ACCESS_GRANT_PRIORITY,
    );
  }
}

/**
 * Lists all the books to which the current user has access.
 *
 * @param $grant
 *   A value between 'view', 'update', and 'delete'.
 *
 * @return
 *   An array containing the node ID of the books to which the user has access.
 */
function book_access_user_books_list($grant) {
  global $user;
  $permitted_bids = array();

  $query = db_query(
    "SELECT nid FROM {book_access_author} WHERE uid = %d AND grant_$grant > 0",
    $user->uid
  );

  while ($result = db_fetch_object($query)) {
    $permitted_bids[$result->nid] = $result->nid;
  }

  $roles = array_keys($user->roles);
  $query = db_query(
    "SELECT nid FROM {book_access_role} WHERE rid IN (" . db_placeholders($roles) . ") AND grant_$grant > 0",
    $roles
  );

  while ($result = db_fetch_object($query)) {
    $permitted_bids[$result->nid] = $result->nid;
  }

  $query = db_query(
    "SELECT nid FROM {book_access_user} WHERE uid = %d AND grant_$grant > 0",
    $user->uid
  );

  while ($result = db_fetch_object($query)) {
    $permitted_bids[$result->nid] = $result->nid;
  }

  return $permitted_bids;
}

/**
 * Gets the list of grant records assigned to users for a book.
 *
 * @param $grants
 *   An array of grants.
 * @param $bid
 *   The ID of the book for which the function returns the grant records.
 */
function book_access_user_records(&$grants, $bid) {
  $result = db_query("SELECT * FROM {book_access_user} WHERE nid = %d", $bid);

  while ($grant = db_fetch_object($result)) {
    $grants[] = array(
      'realm'        => 'book_access_user',
      'gid'          => $grant->uid,
      'grant_view'   => $grant->grant_view,
      'grant_update' => $grant->grant_update,
      'grant_delete' => $grant->grant_delete,
      'priority'     => BOOK_ACCESS_GRANT_PRIORITY,
    );
  }
}

/**
 * Adds user grants to book pages.
 *
 * @param $bid
 *   The book ID.
 * @param $uids
 *   An array of user IDs for which to add the book grants.
 * @param $grants
 *   An array of grants, in the format @code $grants[$grant][$uid] @endcode,
 *   where @code $grant @endcode is a string between "grant_view",
 *   'grant_update', 'grant_delete', 'grant_admin_access', 'grant_add_child',
 *   'grant_edit_outline', and @code $uid @endcode is the user ID.
 */
function book_access_user_add($bid, array $uids, array $grants) {
  $grant_ids = array(
    'grant_view', 'grant_update', 'grant_delete',
    'grant_admin_access', 'grant_add_child', 'grant_edit_outline',
  );

  foreach ($uids as $uid) {
    if ($user = user_load($uid)) {
      $bool = db_result(
        db_query_range(
          "SELECT 1 FROM {book_access_user} WHERE nid = %d AND uid = %d",
          $bid, $user->uid, 0, 1
        )
      );
      $row = new stdClass();
      $row->nid = $bid;
      $row->uid = $user->uid;

      foreach ($grant_ids as $id) {
        $row->$id = !empty($grants[$id][$uid]);
      }

      drupal_write_record('book_access_user', $row, $bool ? array('nid', 'uid') : array());
    }
  }
}

/**
 * Restricts the options available to who moves book pages between books.
 *
 * We don't want users to be able to add child pages to pages they do not
 * have update grants for; therefore, we remove select options which point
 * to book pages user does not have that grant.
 *
 * @param $options
 *   The options array used from book_outline_form() and the book edit form for
 *   the list of books to which the page can be moved to.
 *
 * @see book_access_form_alter()
 */
function _book_access_options_restrict(&$options) {
  if (user_access('administer nodes')) {
    return;
  }

  $permitted_bids = book_access_user_books_list('update');

  if (isset($options)) {
    foreach ($options as $bid => $value) {
      if ($bid > 0 && !isset($permitted_bids[$bid])) {
        unset($options[$bid]);
      }
    }
  }
}
